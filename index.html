<!DOCTYPE html>
<html lang="fa" dir="rtl">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Coliber â€” Connected Smart AI</title>
<link href="https://fonts.googleapis.com/css2?family=Vazirmatn:wght@300;400;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg1:#071021; --bg2:#0b1220; --neon:#00eaff; --accent:#ff4dd2;
    --panel-bg: rgba(255,255,255,0.03);
  }
  *{box-sizing:border-box}
  body{
    margin:0; font-family:'Vazirmatn',sans-serif; color:#e6f7ff;
    background: linear-gradient(180deg,var(--bg1),var(--bg2));
    height:100vh; display:flex; align-items:center; justify-content:center;
  }
  .app{ width:94%; max-width:980px; height:92vh; display:flex; flex-direction:column; gap:12px; padding:18px; }
  .top{ display:flex; justify-content:space-between; align-items:center; gap:12px; background:var(--panel-bg); padding:12px; border-radius:12px; box-shadow:0 10px 40px rgba(0,0,0,0.5); }
  .brand{ font-weight:700; font-size:18px; }
  .muted{ color:#bcd; font-size:13px; margin-top:4px; }
  #chat{ flex:1; padding:16px; overflow:auto; border-radius:12px; background: linear-gradient(180deg, rgba(0,0,0,0.18), rgba(0,0,0,0.32)); box-shadow: inset 0 1px 0 rgba(255,255,255,0.02); }
  .msg{ display:inline-block; padding:12px 14px; margin:10px 0; border-radius:14px; max-width:78%; line-height:1.5; word-break:break-word; opacity:0; transform: translateY(8px); transition: all .28s ease; }
  .msg.show{ opacity:1; transform: translateY(0); }
  .user{ margin-left:auto; background: linear-gradient(90deg,#022b3a,#03506f); box-shadow: 0 6px 30px rgba(2,43,58,0.25); color:#eaffff;}
  .bot{ margin-right:auto; background: linear-gradient(90deg,#2b1b3f,#6835a0); box-shadow: 0 6px 30px rgba(104,53,160,0.12); color:#fff; }
  .status{ display:flex; gap:8px; align-items:center; }
  .kbd{ background:rgba(0,0,0,0.25); padding:6px 8px; border-radius:8px; font-weight:700; color:#bfe; }
  .controls{ display:flex; gap:8px; background:var(--panel-bg); padding:12px; border-radius:12px; align-items:center; }
  input[type="text"]{ flex:1; padding:12px; border-radius:10px; border:1px solid rgba(255,255,255,0.04); background:rgba(0,0,0,0.25); color:inherit; outline:none; font-size:15px; }
  button{ padding:10px 14px; border-radius:10px; border:none; background:var(--neon); color:#002; font-weight:700; cursor:pointer; }
  .small{ font-size:13px; color:#bcd; }
  .hint{ font-size:13px; color:#9cc; margin-left:8px; }
  /* typing bubble */
  .typing { display:flex; gap:6px; align-items:center; padding:8px 12px; border-radius:12px; background: rgba(255,255,255,0.03); width:160px; }
  .dot{ width:8px; height:8px; background:#fff; border-radius:50%; opacity:0.35; animation: blink 1s infinite; }
  .dot:nth-child(2){ animation-delay: .15s }
  .dot:nth-child(3){ animation-delay: .3s }
  @keyframes blink { 0%{opacity:.15} 50%{opacity:1} 100%{opacity:.15} }
  /* hover effects */
  .msg:hover{ transform: translateY(-4px) scale(1.01); filter:brightness(1.05) }
  /* responsive */
  @media (max-width:560px){
    .app{ padding:10px }
    .brand{ font-size:16px }
  }
</style>
</head>
<body>
  <div class="app" role="application">
    <div class="top">
      <div>
        <div class="brand">Coliber</div>
        <div class="muted">Ù‡ÙˆØ´ Ù…ØªØµÙ„ Ø¨Ù‡ ChatGPT â€” Ø­Ø§ÙØ¸Ù‡ Ù…Ø­Ù„ÛŒØŒ ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø± Ùˆ Ø§Ù†ÛŒÙ…ÛŒØ´Ù†</div>
      </div>
      <div class="status">
        <button id="setKeyBtn">Set API Key</button>
        <div class="kbd" id="apiStatus">API: âŒ</div>
      </div>
    </div>

    <div id="chat" aria-live="polite" role="log"></div>

    <div class="controls" role="region" aria-label="Controls">
      <input id="input" type="text" placeholder="Ø³Ø¤Ø§Ù„ ÛŒØ§ Ù¾ÛŒØ§Ù… Ø¨Ù†ÙˆÛŒØ³ â€” Enter Ø¨Ø±Ø§ÛŒ Ø§Ø±Ø³Ø§Ù„" autocomplete="off" />
      <button id="send">Ø§Ø±Ø³Ø§Ù„</button>
      <button id="teach">ÛŒØ§Ø¯ Ø¨Ú¯ÛŒØ±</button>
      <div class="hint small">ÙØ±Ù…Øª ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ: Ø¹Ø¨Ø§Ø±Øª = Ù¾Ø§Ø³Ø®</div>
    </div>

    <div class="small" style="margin-top:6px">Ù†Ú©ØªÙ‡ Ø§Ù…Ù†ÛŒØªÛŒ: Ø¨Ø±Ø§ÛŒ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø¹Ù…ÙˆÙ…ÛŒ Ø§Ø² Coliber Ø§Ø² Ø³Ø±ÙˆØ± ÙˆØ§Ø³Ø· Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù† ØªØ§ Ú©Ù„ÛŒØ¯ Ù…Ø­ÙÙˆØ¸ Ø¨Ù…Ø§Ù†Ø¯.</div>
  </div>

<script>
/* ======== Coliber client logic (single HTML file) ========
   - local memory (localStorage)
   - automatic ChatGPT query when not found
   - retry logic, safe feedback, no asking user for meaning
   - Set API Key button stores key in localStorage
   - typing animation + storing answers
   ======================================================== */

const chatEl = document.getElementById('chat');
const inputEl = document.getElementById('input');
const sendBtn = document.getElementById('send');
const teachBtn = document.getElementById('teach');
const setKeyBtn = document.getElementById('setKeyBtn');
const apiStatus = document.getElementById('apiStatus');

const MEM_KEY = 'coliber_memory_v_final';
let memory = JSON.parse(localStorage.getItem(MEM_KEY) || '{}');
let API_KEY = localStorage.getItem('coliber_api_key') || null;
updateApiStatus();

// helper: add message bubble (with optional typing effect)
function addMessage(text, who='bot', typing=false, typingSpeed=18){
  const div = document.createElement('div');
  div.className = 'msg ' + (who==='user' ? 'user' : 'bot');
  chatEl.appendChild(div);
  chatEl.scrollTop = chatEl.scrollHeight;

  if(!typing){
    div.innerText = text;
    div.classList.add('show');
    chatEl.scrollTop = chatEl.scrollHeight;
    return;
  }

  // typing simulation
  let i = 0;
  const showNext = ()=>{
    i++;
    div.innerText = text.slice(0, i);
    if(!div.classList.contains('show')) div.classList.add('show');
    chatEl.scrollTop = chatEl.scrollHeight;
    if(i < text.length) setTimeout(showNext, typingSpeed);
  };
  showNext();
}

// small helper to show a temporary typing indicator (for UX)
function showTypingIndicator(){
  const t = document.createElement('div');
  t.className = 'msg bot typing';
  t.innerHTML = '<div class="dot"></div><div class="dot"></div><div class="dot"></div>';
  chatEl.appendChild(t);
  chatEl.scrollTop = chatEl.scrollHeight;
  return t;
}

// update API status UI
function updateApiStatus(){ apiStatus.innerText = API_KEY ? 'API: âœ…' : 'API: âŒ'; }

// set API key (stored in localStorage for convenience â€” for public use prefer server proxy)
setKeyBtn.onclick = ()=>{
  const key = prompt('Ú©Ù„ÛŒØ¯ OpenAI API Ø±Ø§ Ø§ÛŒÙ†Ø¬Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù† (Ù…Ø®ÙÛŒ Ù†Ú¯Ù‡ Ø¯Ø§Ø±):');
  if(key && key.trim().length>10){
    API_KEY = key.trim();
    localStorage.setItem('coliber_api_key', API_KEY);
    updateApiStatus();
    alert('Ú©Ù„ÛŒØ¯ Ø°Ø®ÛŒØ±Ù‡ Ø´Ø¯ (localStorage).');
  }
};

// teach button: "key = value" into memory
teachBtn.onclick = ()=>{
  const txt = inputEl.value.trim();
  if(!txt){ inputEl.focus(); return; }
  const parts = txt.split('=');
  if(parts.length>=2){
    const key = parts[0].trim();
    const val = parts.slice(1).join('=').trim();
    memory[key] = val;
    try{ localStorage.setItem(MEM_KEY, JSON.stringify(memory)); }catch(e){ console.warn(e); }
    addMessage(`ÛŒØ§Ø¯ Ú¯Ø±ÙØªÙ…: Â«${key}Â» â†’ Â«${val}Â»`,'bot');
    inputEl.value = '';
  } else {
    addMessage('ÙØ±Ù…Øª ÛŒØ§Ø¯Ú¯ÛŒØ±ÛŒ: Ø¹Ø¨Ø§Ø±Øª = Ù¾Ø§Ø³Ø®','bot');
  }
};

// find memory key with improved fuzzy matching
function findMemoryKey(input){
  const q = input.toLowerCase().trim();
  if(!q) return null;
  // exact
  for(const k of Object.keys(memory)){
    if(k.toLowerCase() === q) return k;
  }
  // contains or token match
  for(const k of Object.keys(memory)){
    const lk = k.toLowerCase();
    if(q.includes(lk) || lk.includes(q)) return k;
    // token intersection
    const a = q.split(/\s+/), b = lk.split(/\s+/);
    const common = a.filter(x => b.includes(x));
    if(common.length >= Math.max(1, Math.floor(Math.min(a.length,b.length)/2))) return k;
  }
  return null;
}

// robust askChatGPT using either direct OpenAI or proxy (if you set PROXY_URL variable)
const PROXY_URL = null; // <-- if you deploy a proxy server, put its URL here like 'https://your-proxy.com/api/chat'

async function askChatGPT(prompt){
  // system-level instruction to make Coliber behave well
  const systemMsg = `ØªÙˆ Coliber Ù‡Ø³ØªÛŒØ› Ù¾ÛŒØ§Ù… Ú©Ø§Ø±Ø¨Ø± Ø±Ø§ ØªØ­Ù„ÛŒÙ„ Ú©Ù† Ùˆ Ù…Ø¹Ù†Ø§ Ùˆ Ù¾Ø§Ø³Ø® Ù…Ù†Ø§Ø³Ø¨ Ø±Ø§ Ø¨Ù‡ ÙØ§Ø±Ø³ÛŒØŒ Ø³Ø§Ø¯Ù‡ Ùˆ Ù…Ø³ØªÙ‚ÛŒÙ… Ø¨Ø¯Ù‡.
  Ù‡ÛŒÚ†â€ŒÙˆÙ‚Øª Ø§Ø² Ú©Ø§Ø±Ø¨Ø± Ù†Ù¾Ø±Ø³ Ù…Ø¹Ù†ÛŒØ´ Ú†ÛŒØ³Øª. Ø§Ú¯Ø± Ù…Ø«Ø§Ù„ ÛŒØ§ ØªÙˆØ¶ÛŒØ­ Ù„Ø§Ø²Ù… Ø§Ø³ØªØŒ ÛŒÚ© Ù…Ø«Ø§Ù„ Ú©ÙˆØªØ§Ù‡ Ø¨ÛŒØ§ÙˆØ±. Ù¾Ø§Ø³Ø® Ø±Ø§ Ù…Ø®ØªØµØ± Ùˆ Ù…ÙÛŒØ¯ Ù†Ú¯Ù‡ Ø¯Ø§Ø±.`;
  // payload
  const payload = {
    model: 'gpt-3.5-turbo',
    messages: [
      {role:'system', content: systemMsg},
      {role:'user', content: prompt}
    ],
    max_tokens: 700,
    temperature: 0.15
  };

  try {
    // choose endpoint: proxy (preferred for public) or direct OpenAI
    const endpoint = PROXY_URL ? (PROXY_URL) : 'https://api.openai.com/v1/chat/completions';
    const headers = { 'Content-Type': 'application/json' };
    if(!PROXY_URL){
      if(!API_KEY) throw new Error('NO_API_KEY');
      headers['Authorization'] = 'Bearer ' + API_KEY;
    }
    const res = await fetch(endpoint, {
      method: 'POST',
      headers,
      body: JSON.stringify(PROXY_URL ? payload : { ...payload })
    });
    if(!res.ok){
      console.error('API error', res.status);
      return null;
    }
    const j = await res.json();
    // support proxy responses that wrap the OpenAI response or direct
    const content = (j.choices && j.choices[0] && j.choices[0].message && j.choices[0].message.content) || j.result || null;
    return content ? content.trim() : null;
  } catch(err){
    console.error('askChatGPT error', err);
    return null;
  }
}

// main sender: checks memory -> queries ChatGPT -> saves result
sendBtn.onclick = async ()=>{
  const text = inputEl.value.trim();
  if(!text) return;
  addMessage(text, 'user');
  inputEl.value = '';

  // 1) memory lookup
  const memKey = findMemoryKey(text);
  if(memKey){
    addMessage(memory[memKey], 'bot', true, 18);
    return;
  }

  // 2) if no API key and no proxy => instruct the user to set key
  if(!API_KEY && !PROXY_URL){
    addMessage('âŒ Ú©Ù„ÛŒØ¯ API ØªÙ†Ø¸ÛŒÙ… Ù†Ø´Ø¯Ù‡. Ø¨Ø±Ø§ÛŒ Ù¾Ø§Ø³Ø®â€ŒØ¯Ù‡ÛŒ Ø®ÙˆØ¯Ú©Ø§Ø±ØŒ Ø±ÙˆÛŒ "Set API Key" Ú©Ù„ÛŒÚ© Ú©Ù†.', 'bot');
    return;
  }

  // 3) ask ChatGPT (with small retry logic)
  const typingNode = showTypingIndicator();
  let answer = null;
  try{
    answer = await askChatGPT(text);
    if(!answer || answer.trim().length===0){
      // retry once
      answer = await askChatGPT(text);
    }
  }catch(e){
    console.error(e);
  } finally {
    // remove typing indicator
    if(typingNode && typingNode.parentNode) typingNode.parentNode.removeChild(typingNode);
  }

  if(answer && answer.trim().length>0){
    // display with typing animation
    addMessage(answer, 'bot', true, 18);
    // save to memory (key: user original text -> value: answer)
    try {
      memory[text] = answer;
      localStorage.setItem(MEM_KEY, JSON.stringify(memory));
    } catch(e){
      console.warn('localStorage store error', e);
    }
    return;
  } else {
    // final fallback message (API failed)
    addMessage('âš ï¸ Ù…ØªØ£Ø³ÙØ§Ù†Ù‡ Ù¾Ø§Ø³Ø® Ù…Ø¹ØªØ¨Ø± Ù†Ú¯Ø±ÙØªÙ… â€” Ø§Ø­ØªÙ…Ø§Ù„Ø§Ù‹ Ù…Ø´Ú©Ù„ Ø´Ø¨Ú©Ù‡ ÛŒØ§ Ø³Ø±ÙˆÛŒØ³. Ø¨Ø¹Ø¯Ø§Ù‹ Ø¯ÙˆØ¨Ø§Ø±Ù‡ ØªÙ„Ø§Ø´ Ú©Ù†.', 'bot');
    return;
  }
};

// allow Enter to send
inputEl.addEventListener('keydown', (e)=>{ if(e.key==='Enter') sendBtn.click(); });

// initial greeting
addMessage('Ø³Ù„Ø§Ù…! Ù…Ù† Coliber Ù‡Ø³ØªÙ… â€” Ù…ÛŒâ€ŒØªÙˆÙ†Ù… Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§Øª Ø±Ùˆ Ø¨ÙÙ‡Ù…Ù… Ùˆ Ø¨Ø¯ÙˆÙ† Ù¾Ø±Ø³ÛŒØ¯Ù† Ø§Ø²Øª Ø§Ø² ChatGPT Ø¬ÙˆØ§Ø¨ Ø¨Ú¯ÛŒØ±Ù…. Ø¨Ø±Ø§ÛŒ ÙØ¹Ø§Ù„ Ø´Ø¯Ù†ØŒ Set API Key Ú©Ù† ÛŒØ§ Ø§Ø² proxy Ø§Ù…Ù† Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†. ğŸŒŸ','bot');

</script>
</body>
</html>
